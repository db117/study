#JVM结构基础
####双亲委派模型
* 同一个类只会加载一次,防止开发者覆盖Java底层库
* 启动类加载器(Bootstrap):
    * 负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）
* 标准扩展类加载器（Extension）:
    * 它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。
    * 开发者可以直接使用标准扩展类加载器
* 应用程序类加载器：（Application）
    * 它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。
    * 由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，
    因此一般称为系统（System）加载器.
        
####类加载过程
* 加载
    *   程序运行之前jvm会把编译完成的.class二进制文件加载到内存，供程序使用，
    用到的就是类加载器classLoader
    *   取得类的二进制字节流，通过类的全限定名称（包名+类名）
    *   把二进制字节流中静态存储结构转化为方法区数据结构
    *   在内存中生成代表这个类的java.lang.Class对象，这里是放在堆中 
* 连接
    * 验证    
        *   确保类加载的正确性
        *   验证类的格式是否正确
        *   文件格式的验证
        *   元数据验证
        *   字节码验证
        *   符号引用验证
    * 准备
        *   为类的静态变量分配内存，将其初始化为默认值 
    * 解析
        *   把类中的符号引用转化为直接引用
* 初始化
    *   为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值
    ，此处赋予的才是程序编写者为变量分配的真正的初始值
    *   如果这个类还没有被加载和链接，那就先加载和链接
    *   如果类存在直接的父类，先初始化直接父类
    *   如果类中存在初始化语句，那就依次执行初始化语句
    *   类的构造器<clinit>: 由编译器自动收集
        *   static{}语句
        *   static变量
####类的初始化时机
*   new，创建类的实例对象
*   反射
*   调用类的静态方法
*   初始化类的子类，此时需要先要初始化父类
*   访问类中的静态变量或者给静态变量赋值
*   Jvm启动的时候的启动类

####JVM运行时数据区
*   程序计数器(Program Counter Register)
    *   当前线程执行的字节码的行号指示器，通过改变此指示器来选取下一个需要执行的字节码指令
    *   在线程创建时创建
    *   每个线程拥有一个
    *   指向下一条指令的地址
*   方法区(Method Area(Non-Heap))
    *   线程共享
    *   存储
        *   类信息
        *   常量
        *   静态变量
        *   方法字节码
*   VM堆栈/本机方法堆栈(VM Stack / Native Method Stack)
    *   线程私有
    *   方法在执行时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息
    *   方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
    *   局部变量表所需的内存空间在编译期间完成分配，而且分配多大的局部变量空间是完全确定的，
    在方法运行期间不会改变其大小
    *   出栈后空间释放
*   堆(Heap)
    *   线程共享
    *   存储对象或数组
    *   Heap划分
        *   年轻带
            *   eden(新生代)
            *   s0
            *   s1
        *   Tenured(老年代)
####指令重排

####Volatile
*   可见性

####Trace跟踪参数
*   -verbose:gc
        打印GC日志信息
*   -XX:+PrintGCDetails
        打印GC日志信息
*   -Xloggc:d:/gc.log 
        GC日志目录
*   -XX:+PrintHeapAtGC 
        每次一次GC后，都打印堆信息
*   -XX:+TraceClassLoading
        类加载信息
####Heap内存分配参数
*   -Xmx 
        最大堆
*   –Xms
        最小堆
*   -Xmn 
        新生代大小 （eden+2s)
*   –XX:NewRatio 
        年轻代（eden+2s）：老年代
*   –XX:SurvivorRatio  2s:eden 
####Stack内存分配参数
*   -Xss
    *   决定方法调用的深度
    *   没个线程独有栈空间
    *   参数，局部变量分配在栈上
    *   一般几百K就够了，64位jvm默认1M
####JVM内存回收
*   标记-清除算法
    *   标记阶段
        *   标记存活对象
    *   清除阶段
        *   统一回收所有未标记的对象
    *   缺点
        *   会产生内存碎片,如果空间内存碎片太多，当程序产生大对象无法在堆
        中找到连续空间大小存放的时候，会强制发生GC

*   复制算法
    *   原理
        *   内存一分为二，每次只使用其中一块，当一块内存没有连续空间存储对象的时候
        ，会把存活下来的对象复制到另外一块内存中，然后一次性清除之前的哪块空间
    *   优缺点
        *   没有内存碎片问题
        *   代价就是讲内存减少了一半，空间利用率不高
        *   不适用于存活对象较多的场景，比如老年代
    *   而实际上我们并不需要按照1:1的比例来划分，因为大部分对象从创建到结束这个生命周期很短
    *   HotSpot虚拟机默认Eden:Survivor=8:1

*   标记-整理算法
    *   原理
        *   标记存活对象，然后把存活对象向一端移动
        *   清理掉存活对象这端以外的所有空间
    *   适合用于存活对象较多的场合，如老年代
    *  解决了空间碎片和效率问题：
        将所有的存活对象压缩到内存的一端，然后清理边界外所有的空间

*   分代收集算法
    *   分代思想
        *   堆划分为新生代和老年代
        *   新生代中，能够存活的对象很少，可以使用复制算法
        *   老年代中，对象存活率高，而且没有额外的空间用来做老年代的担保，可以使用标记清除或者标记整理算法
####垃圾收集器-GC
*   Serial  新生代串行收集器 新（复制算法），老（标记整理）
*   ParNew 新生代并行收集器
*   Parallel Scavenge 新生代并行收集器
    *   目标：尽可能缩GC时用户线程的停顿时间
    *   在注重吞吐量或CPU资源敏感的场合，可以优先考虑Parallel Scavenge收集器 + Parallel Old收集器
*   Serial Old 老年代串行收集器
*   Parallel Old 老年代并行收集器
*   CMS 真正意义上的并发收集器（老年代收集器）
    *   目标：最短的GC停顿时间
*   G1
